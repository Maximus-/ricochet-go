// Code generated by protoc-gen-go.
// source: core.proto
// DO NOT EDIT!

package ricochet

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Reply struct {
}

func (m *Reply) Reset()                    { *m = Reply{} }
func (m *Reply) String() string            { return proto.CompactTextString(m) }
func (*Reply) ProtoMessage()               {}
func (*Reply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type ServerStatusRequest struct {
	RpcVersion int32 `protobuf:"varint,1,opt,name=rpcVersion" json:"rpcVersion,omitempty"`
}

func (m *ServerStatusRequest) Reset()                    { *m = ServerStatusRequest{} }
func (m *ServerStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*ServerStatusRequest) ProtoMessage()               {}
func (*ServerStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ServerStatusRequest) GetRpcVersion() int32 {
	if m != nil {
		return m.RpcVersion
	}
	return 0
}

type ServerStatusReply struct {
	RpcVersion    int32  `protobuf:"varint,1,opt,name=rpcVersion" json:"rpcVersion,omitempty"`
	ServerVersion string `protobuf:"bytes,2,opt,name=serverVersion" json:"serverVersion,omitempty"`
}

func (m *ServerStatusReply) Reset()                    { *m = ServerStatusReply{} }
func (m *ServerStatusReply) String() string            { return proto.CompactTextString(m) }
func (*ServerStatusReply) ProtoMessage()               {}
func (*ServerStatusReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *ServerStatusReply) GetRpcVersion() int32 {
	if m != nil {
		return m.RpcVersion
	}
	return 0
}

func (m *ServerStatusReply) GetServerVersion() string {
	if m != nil {
		return m.ServerVersion
	}
	return ""
}

func init() {
	proto.RegisterType((*Reply)(nil), "ricochet.Reply")
	proto.RegisterType((*ServerStatusRequest)(nil), "ricochet.ServerStatusRequest")
	proto.RegisterType((*ServerStatusReply)(nil), "ricochet.ServerStatusReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RicochetCore service

type RicochetCoreClient interface {
	// Query RPC server version and status
	GetServerStatus(ctx context.Context, in *ServerStatusRequest, opts ...grpc.CallOption) (*ServerStatusReply, error)
	// Open a stream to monitor changes to network status. The current
	// NetworkStatus will be sent immediately, and the stream will receive a
	// new NetworkStatus after any changes until the stream is closed.
	MonitorNetwork(ctx context.Context, in *MonitorNetworkRequest, opts ...grpc.CallOption) (RicochetCore_MonitorNetworkClient, error)
	// Start connecting to the network. Before StartNetwork is called (by any
	// client), the backend will not make any connections or appear online.
	// This call blocks until the first connection attempt succeeds or fails,
	// and returns the current network status, but connection attempts will
	// continue unless this call returns an RPC error, or until StopNetwork
	// is called.
	StartNetwork(ctx context.Context, in *StartNetworkRequest, opts ...grpc.CallOption) (*NetworkStatus, error)
	// Stop all network connections and go offline. Blocks until the network
	// has been taken offline, and returns the new network status.
	StopNetwork(ctx context.Context, in *StopNetworkRequest, opts ...grpc.CallOption) (*NetworkStatus, error)
	GetIdentity(ctx context.Context, in *IdentityRequest, opts ...grpc.CallOption) (*Identity, error)
	// Query contacts and monitor for contact changes. The full contact list
	// is sent in POPULATE events, terminated by a POPULATE event with no
	// subject. Any new, removed, or modified contacts, including changes in
	// the state of contacts, are sent as ADD, UPDATE, or DELETE events until
	// the stream is closed.
	MonitorContacts(ctx context.Context, in *MonitorContactsRequest, opts ...grpc.CallOption) (RicochetCore_MonitorContactsClient, error)
	AddContactRequest(ctx context.Context, in *ContactRequest, opts ...grpc.CallOption) (*Contact, error)
	UpdateContact(ctx context.Context, in *Contact, opts ...grpc.CallOption) (*Contact, error)
	DeleteContact(ctx context.Context, in *DeleteContactRequest, opts ...grpc.CallOption) (*DeleteContactReply, error)
	AcceptInboundRequest(ctx context.Context, in *ContactRequest, opts ...grpc.CallOption) (*Contact, error)
	RejectInboundRequest(ctx context.Context, in *ContactRequest, opts ...grpc.CallOption) (*RejectInboundRequestReply, error)
	// Open a stream to monitor messages in conversations with contacts.
	MonitorConversations(ctx context.Context, in *MonitorConversationsRequest, opts ...grpc.CallOption) (RicochetCore_MonitorConversationsClient, error)
	SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error)
	MarkConversationRead(ctx context.Context, in *MarkConversationReadRequest, opts ...grpc.CallOption) (*Reply, error)
}

type ricochetCoreClient struct {
	cc *grpc.ClientConn
}

func NewRicochetCoreClient(cc *grpc.ClientConn) RicochetCoreClient {
	return &ricochetCoreClient{cc}
}

func (c *ricochetCoreClient) GetServerStatus(ctx context.Context, in *ServerStatusRequest, opts ...grpc.CallOption) (*ServerStatusReply, error) {
	out := new(ServerStatusReply)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/GetServerStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) MonitorNetwork(ctx context.Context, in *MonitorNetworkRequest, opts ...grpc.CallOption) (RicochetCore_MonitorNetworkClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RicochetCore_serviceDesc.Streams[0], c.cc, "/ricochet.RicochetCore/MonitorNetwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &ricochetCoreMonitorNetworkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RicochetCore_MonitorNetworkClient interface {
	Recv() (*NetworkStatus, error)
	grpc.ClientStream
}

type ricochetCoreMonitorNetworkClient struct {
	grpc.ClientStream
}

func (x *ricochetCoreMonitorNetworkClient) Recv() (*NetworkStatus, error) {
	m := new(NetworkStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ricochetCoreClient) StartNetwork(ctx context.Context, in *StartNetworkRequest, opts ...grpc.CallOption) (*NetworkStatus, error) {
	out := new(NetworkStatus)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/StartNetwork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) StopNetwork(ctx context.Context, in *StopNetworkRequest, opts ...grpc.CallOption) (*NetworkStatus, error) {
	out := new(NetworkStatus)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/StopNetwork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) GetIdentity(ctx context.Context, in *IdentityRequest, opts ...grpc.CallOption) (*Identity, error) {
	out := new(Identity)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/GetIdentity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) MonitorContacts(ctx context.Context, in *MonitorContactsRequest, opts ...grpc.CallOption) (RicochetCore_MonitorContactsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RicochetCore_serviceDesc.Streams[1], c.cc, "/ricochet.RicochetCore/MonitorContacts", opts...)
	if err != nil {
		return nil, err
	}
	x := &ricochetCoreMonitorContactsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RicochetCore_MonitorContactsClient interface {
	Recv() (*ContactEvent, error)
	grpc.ClientStream
}

type ricochetCoreMonitorContactsClient struct {
	grpc.ClientStream
}

func (x *ricochetCoreMonitorContactsClient) Recv() (*ContactEvent, error) {
	m := new(ContactEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ricochetCoreClient) AddContactRequest(ctx context.Context, in *ContactRequest, opts ...grpc.CallOption) (*Contact, error) {
	out := new(Contact)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/AddContactRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) UpdateContact(ctx context.Context, in *Contact, opts ...grpc.CallOption) (*Contact, error) {
	out := new(Contact)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/UpdateContact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) DeleteContact(ctx context.Context, in *DeleteContactRequest, opts ...grpc.CallOption) (*DeleteContactReply, error) {
	out := new(DeleteContactReply)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/DeleteContact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) AcceptInboundRequest(ctx context.Context, in *ContactRequest, opts ...grpc.CallOption) (*Contact, error) {
	out := new(Contact)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/AcceptInboundRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) RejectInboundRequest(ctx context.Context, in *ContactRequest, opts ...grpc.CallOption) (*RejectInboundRequestReply, error) {
	out := new(RejectInboundRequestReply)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/RejectInboundRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) MonitorConversations(ctx context.Context, in *MonitorConversationsRequest, opts ...grpc.CallOption) (RicochetCore_MonitorConversationsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RicochetCore_serviceDesc.Streams[2], c.cc, "/ricochet.RicochetCore/MonitorConversations", opts...)
	if err != nil {
		return nil, err
	}
	x := &ricochetCoreMonitorConversationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RicochetCore_MonitorConversationsClient interface {
	Recv() (*ConversationEvent, error)
	grpc.ClientStream
}

type ricochetCoreMonitorConversationsClient struct {
	grpc.ClientStream
}

func (x *ricochetCoreMonitorConversationsClient) Recv() (*ConversationEvent, error) {
	m := new(ConversationEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ricochetCoreClient) SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	out := new(Message)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/SendMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ricochetCoreClient) MarkConversationRead(ctx context.Context, in *MarkConversationReadRequest, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := grpc.Invoke(ctx, "/ricochet.RicochetCore/MarkConversationRead", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RicochetCore service

type RicochetCoreServer interface {
	// Query RPC server version and status
	GetServerStatus(context.Context, *ServerStatusRequest) (*ServerStatusReply, error)
	// Open a stream to monitor changes to network status. The current
	// NetworkStatus will be sent immediately, and the stream will receive a
	// new NetworkStatus after any changes until the stream is closed.
	MonitorNetwork(*MonitorNetworkRequest, RicochetCore_MonitorNetworkServer) error
	// Start connecting to the network. Before StartNetwork is called (by any
	// client), the backend will not make any connections or appear online.
	// This call blocks until the first connection attempt succeeds or fails,
	// and returns the current network status, but connection attempts will
	// continue unless this call returns an RPC error, or until StopNetwork
	// is called.
	StartNetwork(context.Context, *StartNetworkRequest) (*NetworkStatus, error)
	// Stop all network connections and go offline. Blocks until the network
	// has been taken offline, and returns the new network status.
	StopNetwork(context.Context, *StopNetworkRequest) (*NetworkStatus, error)
	GetIdentity(context.Context, *IdentityRequest) (*Identity, error)
	// Query contacts and monitor for contact changes. The full contact list
	// is sent in POPULATE events, terminated by a POPULATE event with no
	// subject. Any new, removed, or modified contacts, including changes in
	// the state of contacts, are sent as ADD, UPDATE, or DELETE events until
	// the stream is closed.
	MonitorContacts(*MonitorContactsRequest, RicochetCore_MonitorContactsServer) error
	AddContactRequest(context.Context, *ContactRequest) (*Contact, error)
	UpdateContact(context.Context, *Contact) (*Contact, error)
	DeleteContact(context.Context, *DeleteContactRequest) (*DeleteContactReply, error)
	AcceptInboundRequest(context.Context, *ContactRequest) (*Contact, error)
	RejectInboundRequest(context.Context, *ContactRequest) (*RejectInboundRequestReply, error)
	// Open a stream to monitor messages in conversations with contacts.
	MonitorConversations(*MonitorConversationsRequest, RicochetCore_MonitorConversationsServer) error
	SendMessage(context.Context, *Message) (*Message, error)
	MarkConversationRead(context.Context, *MarkConversationReadRequest) (*Reply, error)
}

func RegisterRicochetCoreServer(s *grpc.Server, srv RicochetCoreServer) {
	s.RegisterService(&_RicochetCore_serviceDesc, srv)
}

func _RicochetCore_GetServerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).GetServerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/GetServerStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).GetServerStatus(ctx, req.(*ServerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_MonitorNetwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonitorNetworkRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RicochetCoreServer).MonitorNetwork(m, &ricochetCoreMonitorNetworkServer{stream})
}

type RicochetCore_MonitorNetworkServer interface {
	Send(*NetworkStatus) error
	grpc.ServerStream
}

type ricochetCoreMonitorNetworkServer struct {
	grpc.ServerStream
}

func (x *ricochetCoreMonitorNetworkServer) Send(m *NetworkStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _RicochetCore_StartNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).StartNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/StartNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).StartNetwork(ctx, req.(*StartNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_StopNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).StopNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/StopNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).StopNetwork(ctx, req.(*StopNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_GetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).GetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/GetIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).GetIdentity(ctx, req.(*IdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_MonitorContacts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonitorContactsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RicochetCoreServer).MonitorContacts(m, &ricochetCoreMonitorContactsServer{stream})
}

type RicochetCore_MonitorContactsServer interface {
	Send(*ContactEvent) error
	grpc.ServerStream
}

type ricochetCoreMonitorContactsServer struct {
	grpc.ServerStream
}

func (x *ricochetCoreMonitorContactsServer) Send(m *ContactEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _RicochetCore_AddContactRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).AddContactRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/AddContactRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).AddContactRequest(ctx, req.(*ContactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_UpdateContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Contact)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).UpdateContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/UpdateContact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).UpdateContact(ctx, req.(*Contact))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_DeleteContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteContactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).DeleteContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/DeleteContact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).DeleteContact(ctx, req.(*DeleteContactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_AcceptInboundRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).AcceptInboundRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/AcceptInboundRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).AcceptInboundRequest(ctx, req.(*ContactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_RejectInboundRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).RejectInboundRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/RejectInboundRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).RejectInboundRequest(ctx, req.(*ContactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_MonitorConversations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonitorConversationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RicochetCoreServer).MonitorConversations(m, &ricochetCoreMonitorConversationsServer{stream})
}

type RicochetCore_MonitorConversationsServer interface {
	Send(*ConversationEvent) error
	grpc.ServerStream
}

type ricochetCoreMonitorConversationsServer struct {
	grpc.ServerStream
}

func (x *ricochetCoreMonitorConversationsServer) Send(m *ConversationEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _RicochetCore_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).SendMessage(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _RicochetCore_MarkConversationRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkConversationReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RicochetCoreServer).MarkConversationRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ricochet.RicochetCore/MarkConversationRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RicochetCoreServer).MarkConversationRead(ctx, req.(*MarkConversationReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RicochetCore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ricochet.RicochetCore",
	HandlerType: (*RicochetCoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServerStatus",
			Handler:    _RicochetCore_GetServerStatus_Handler,
		},
		{
			MethodName: "StartNetwork",
			Handler:    _RicochetCore_StartNetwork_Handler,
		},
		{
			MethodName: "StopNetwork",
			Handler:    _RicochetCore_StopNetwork_Handler,
		},
		{
			MethodName: "GetIdentity",
			Handler:    _RicochetCore_GetIdentity_Handler,
		},
		{
			MethodName: "AddContactRequest",
			Handler:    _RicochetCore_AddContactRequest_Handler,
		},
		{
			MethodName: "UpdateContact",
			Handler:    _RicochetCore_UpdateContact_Handler,
		},
		{
			MethodName: "DeleteContact",
			Handler:    _RicochetCore_DeleteContact_Handler,
		},
		{
			MethodName: "AcceptInboundRequest",
			Handler:    _RicochetCore_AcceptInboundRequest_Handler,
		},
		{
			MethodName: "RejectInboundRequest",
			Handler:    _RicochetCore_RejectInboundRequest_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _RicochetCore_SendMessage_Handler,
		},
		{
			MethodName: "MarkConversationRead",
			Handler:    _RicochetCore_MarkConversationRead_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MonitorNetwork",
			Handler:       _RicochetCore_MonitorNetwork_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MonitorContacts",
			Handler:       _RicochetCore_MonitorContacts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MonitorConversations",
			Handler:       _RicochetCore_MonitorConversations_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "core.proto",
}

func init() { proto.RegisterFile("core.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 462 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x94, 0xd1, 0x6b, 0xd4, 0x40,
	0x10, 0xc6, 0x89, 0x50, 0xad, 0x73, 0x4d, 0xcb, 0x8d, 0x87, 0xd6, 0xb3, 0xd6, 0xe3, 0x54, 0xe8,
	0xd3, 0x51, 0x2c, 0x7d, 0xf3, 0xc1, 0x72, 0xd5, 0x52, 0x30, 0x7d, 0x48, 0xa8, 0x20, 0xf8, 0x92,
	0x6e, 0x06, 0x8d, 0x3d, 0x76, 0xe3, 0xee, 0xdc, 0xc9, 0xfd, 0x11, 0xfe, 0xcf, 0x72, 0xcd, 0x6e,
	0x77, 0x43, 0x72, 0x9c, 0xf8, 0x98, 0xef, 0xf7, 0xcd, 0x97, 0xd9, 0xd9, 0x49, 0x00, 0x84, 0xd2,
	0x34, 0xa9, 0xb4, 0x62, 0x85, 0xdb, 0xba, 0x14, 0x4a, 0xfc, 0x20, 0x1e, 0xc6, 0x92, 0xf8, 0xb7,
	0xd2, 0xb7, 0x35, 0x18, 0xee, 0x96, 0x05, 0x49, 0x2e, 0x79, 0x69, 0x9f, 0x63, 0xa1, 0x24, 0xe7,
	0x82, 0xed, 0x23, 0x0a, 0x25, 0x17, 0xa4, 0x4d, 0xce, 0xa5, 0x92, 0xb5, 0x36, 0x7e, 0x04, 0x5b,
	0x29, 0x55, 0xb3, 0xe5, 0xf8, 0x14, 0x9e, 0x64, 0xa4, 0x17, 0xa4, 0x33, 0xce, 0x79, 0x6e, 0x52,
	0xfa, 0x35, 0x27, 0xc3, 0x78, 0x08, 0xa0, 0x2b, 0xf1, 0x85, 0xb4, 0x29, 0x95, 0xdc, 0x8f, 0x46,
	0xd1, 0xd1, 0x56, 0x1a, 0x28, 0xe3, 0xaf, 0xd0, 0x6f, 0x96, 0x55, 0xb3, 0xe5, 0xa6, 0x22, 0x7c,
	0x03, 0xb1, 0xb9, 0x2b, 0x72, 0x96, 0x07, 0xa3, 0xe8, 0xe8, 0x71, 0xda, 0x14, 0xdf, 0xfd, 0xd9,
	0x86, 0x9d, 0xd4, 0x9e, 0x74, 0xaa, 0x34, 0x61, 0x02, 0x7b, 0x17, 0xc4, 0xe1, 0xeb, 0xf0, 0xe5,
	0xc4, 0xcd, 0x62, 0xd2, 0xd1, 0xfd, 0xf0, 0xc5, 0x3a, 0xbc, 0xea, 0xf2, 0x33, 0xec, 0x26, 0x4a,
	0x96, 0xac, 0xf4, 0x55, 0x3d, 0x45, 0x7c, 0xe5, 0xed, 0x4d, 0xe2, 0xf2, 0x9e, 0x79, 0x83, 0x25,
	0x75, 0xe0, 0x71, 0x84, 0x9f, 0x60, 0x27, 0xe3, 0x5c, 0xb3, 0xcb, 0x0a, 0x3b, 0x0b, 0xf4, 0x4d,
	0x49, 0x78, 0x0e, 0xbd, 0x8c, 0x55, 0xe5, 0x62, 0x0e, 0xc2, 0x98, 0x7b, 0x79, 0x63, 0xca, 0x7b,
	0xe8, 0x5d, 0x10, 0x5f, 0xda, 0x75, 0xc0, 0xe7, 0xde, 0xe7, 0x34, 0x17, 0x81, 0x6d, 0xb4, 0x1a,
	0xb4, 0x3d, 0xff, 0xb4, 0x5e, 0x20, 0x83, 0xa3, 0xd6, 0x68, 0x1c, 0x72, 0x41, 0x4f, 0xbd, 0xc3,
	0xa2, 0x8f, 0x0b, 0x92, 0x7c, 0x1c, 0xe1, 0x07, 0xe8, 0x9f, 0x15, 0x85, 0x15, 0xdd, 0x62, 0xed,
	0xb7, 0xec, 0x2e, 0xa8, 0xdf, 0x22, 0x78, 0x0a, 0xf1, 0x75, 0x55, 0xe4, 0x4c, 0x4e, 0x68, 0x7b,
	0xba, 0xca, 0x12, 0x88, 0xcf, 0x69, 0x46, 0xbe, 0xec, 0xd0, 0x7b, 0x1a, 0xc0, 0xbd, 0xfa, 0x60,
	0x2d, 0x5f, 0x2d, 0xcc, 0x14, 0x06, 0x67, 0x42, 0x50, 0xc5, 0x97, 0xf2, 0x46, 0xcd, 0x65, 0xf1,
	0x5f, 0x47, 0xb9, 0x86, 0x41, 0x4a, 0x3f, 0x49, 0xfc, 0x7b, 0xc8, 0x6b, 0x4f, 0xba, 0x2a, 0xeb,
	0xde, 0xbe, 0xc1, 0xc0, 0xdf, 0xcb, 0xfd, 0x47, 0x6e, 0xf0, 0x6d, 0xd7, 0xbd, 0x79, 0xde, 0xf1,
	0xa1, 0x84, 0xdc, 0xdd, 0xe0, 0x09, 0xf4, 0x32, 0x92, 0x45, 0x42, 0xc6, 0xe4, 0xdf, 0x29, 0x9c,
	0xbe, 0x95, 0x86, 0x6d, 0x09, 0xaf, 0x60, 0x90, 0xe4, 0xfa, 0x36, 0xcc, 0x4b, 0x29, 0x2f, 0x1a,
	0x2d, 0x75, 0x70, 0xd7, 0xd2, 0x5e, 0x78, 0xec, 0x6a, 0xb6, 0xbc, 0x79, 0x78, 0xf7, 0xc7, 0x3a,
	0xf9, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xa5, 0xe8, 0x3e, 0x1e, 0x0b, 0x05, 0x00, 0x00,
}
